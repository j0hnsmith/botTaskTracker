package fragments

import "github.com/j0hnsmith/botTaskTracker/ent"
import "time"

templ ActivityFeed(activity []*ent.TaskHistory) {
	<div class="card bg-base-100 border border-base-300">
		<div class="card-body p-4">
			<div class="flex items-center justify-between mb-3">
				<h3 class="card-title text-base">ðŸ“‹ Activity Stream</h3>
				<div class="flex items-center gap-2">
					<span id="activity-status" class="badge badge-ghost badge-sm">Live</span>
					<span class="badge badge-ghost badge-sm">Last 30 events</span>
				</div>
			</div>
			if len(activity) == 0 {
				<div class="text-center text-gray-500 text-sm py-8">No activity yet</div>
			} else {
				<!-- Timeline -->
				<ul id="activity-timeline" class="timeline timeline-vertical timeline-compact">
					for i, entry := range activity {
						@ActivityItem(entry, i)
					}
				</ul>
			}
		</div>
	</div>
	<!-- SSE Connection for Activity Stream -->
	<script>
		document.addEventListener('DOMContentLoaded', () => {
			let activitySource = null;
			let activityReconnectTimer = null;
			
			function connectActivitySSE() {
				if (activitySource) return;
				
				console.log('[Activity SSE] Connecting...');
				activitySource = new EventSource('/datastar/activity/events');
				
				activitySource.addEventListener('datastar-patch-elements', (e) => {
					console.log('[Activity SSE] Received patch-elements');
					try {
						const lines = e.data.split('\n');
						let selector = '';
						let mode = 'outer';
						let html = '';
						
						for (const line of lines) {
							if (line.startsWith('selector ')) {
								selector = line.substring(9);
							} else if (line.startsWith('mode ')) {
								mode = line.substring(5);
							} else if (line.startsWith('elements ')) {
								html = line.substring(9);
							}
						}
						
						if (html && selector) {
							const target = document.querySelector(selector);
							if (target && mode === 'prepend') {
								const tempDiv = document.createElement('div');
								tempDiv.innerHTML = html;
								const newElement = tempDiv.firstElementChild;
								if (newElement) {
									target.insertBefore(newElement, target.firstChild);
									console.log('[Activity SSE] Prepended to', selector);
								}
							}
						}
					} catch (err) {
						console.error('[Activity SSE] Error processing patch:', err);
					}
				});
				
				activitySource.addEventListener('datastar-execute-script', (e) => {
					console.log('[Activity SSE] Received execute-script');
					try {
						const lines = e.data.split('\n');
						for (const line of lines) {
							if (line.startsWith('script ')) {
								const script = line.substring(7);
								eval(script);
								console.log('[Activity SSE] Executed script');
							}
						}
					} catch (err) {
						console.error('[Activity SSE] Error executing script:', err);
					}
				});
				
				activitySource.onopen = () => {
					console.log('[Activity SSE] Connected');
					const statusBadge = document.getElementById('activity-status');
					if (statusBadge) {
						statusBadge.textContent = 'Live';
						statusBadge.className = 'badge badge-success badge-sm';
					}
					if (activityReconnectTimer) {
						clearTimeout(activityReconnectTimer);
						activityReconnectTimer = null;
					}
				};
				
				activitySource.onerror = (err) => {
					console.error('[Activity SSE] Error:', err);
					activitySource.close();
					activitySource = null;
					
					const statusBadge = document.getElementById('activity-status');
					if (statusBadge) {
						statusBadge.textContent = 'Reconnecting...';
						statusBadge.className = 'badge badge-warning badge-sm';
					}
					
					if (!activityReconnectTimer) {
						activityReconnectTimer = setTimeout(() => {
							activityReconnectTimer = null;
							connectActivitySSE();
						}, 3000);
					}
				};
			}
			
			connectActivitySSE();
			
			// Reconnect when page becomes visible
			document.addEventListener('visibilitychange', () => {
				if (!document.hidden && (!activitySource || activitySource.readyState === EventSource.CLOSED)) {
					console.log('[Activity SSE] Reconnecting after visibility change');
					if (activitySource) {
						activitySource.close();
						activitySource = null;
					}
					connectActivitySSE();
				}
			});
			
			// Cleanup
			window.addEventListener('beforeunload', () => {
				if (activitySource) {
					activitySource.close();
				}
			});
		});
	</script>
}

templ ActivityItem(entry *ent.TaskHistory, index int) {
	<li>
		if index > 0 {
			<hr class={ getTimelineColor(entry) }/>
		}
		<div class="timeline-start text-xs text-base-content/60">{ formatTimeAgo(entry.CreatedAt) }</div>
		<div class="timeline-middle">
			<div class="avatar placeholder">
				<div class={
					"rounded-full w-5 h-5 text-[10px]",
					templ.KV("bg-info text-info-content", entry.Actor == "john"),
					templ.KV("bg-primary text-primary-content", entry.Actor == "peter"),
					templ.KV("bg-accent text-accent-content", entry.Actor != "john" && entry.Actor != "peter"),
				}>
					<span>{ getActorInitial(entry.Actor) }</span>
				</div>
			</div>
		</div>
		<div class="timeline-end timeline-box text-sm">
			<span class="font-medium">{ getActorName(entry.Actor) }</span>
			{ " " }
			{ getActionText(entry.Action) }
			{ " " }
			if entry.Edges.Task != nil {
				<span class="font-medium">"{ entry.Edges.Task.Title }"</span>
			}
			{ " " }
			@getStatusBadge(entry.Action, entry.Details)
		</div>
		<hr class={ getTimelineColor(entry) }/>
	</li>
}

func formatTimeAgo(t time.Time) string {
	duration := time.Since(t)
	if duration < time.Minute {
		return "just now"
	}
	if duration < time.Hour {
		mins := int(duration.Minutes())
		if mins == 1 {
			return "1m ago"
		}
		return string(rune(mins)) + "m ago"
	}
	if duration < 24*time.Hour {
		hours := int(duration.Hours())
		if hours == 1 {
			return "1h ago"
		}
		return string(rune(hours)) + "h ago"
	}
	days := int(duration.Hours() / 24)
	if days == 1 {
		return "1d ago"
	}
	return string(rune(days)) + "d ago"
}

func getActorName(actor string) string {
	if actor == "" {
		return "system"
	}
	return actor
}

func getActorInitial(actor string) string {
	name := getActorName(actor)
	if len(name) > 0 {
		runes := []rune(name)
		return string(runes[0:1])
	}
	return "S"
}

func getAssigneeFromDetails(details string) string {
	// Try to extract assignee name from details
	// This is a simple heuristic - you might need to adjust based on your actual data
	if len(details) > 0 {
		// Default to a name if we can extract it
		// For now, we'll alternate between peter and john
		return "john"
	}
	return "system"
}

func getAssigneeInitial(details string) string {
	name := getAssigneeFromDetails(details)
	if len(name) > 0 {
		return string([]rune(name)[0])
	}
	return "S"
}

func getActionText(action string) string {
	switch action {
	case "created":
		return "created task"
	case "updated":
		return "updated"
	case "moved":
		return "moved"
	case "assigned":
		return "assigned"
	case "completed":
		return "completed"
	case "deleted":
		return "deleted"
	case "tagged":
		return "added tag"
	default:
		return action
	}
}

func getTimelineColor(entry *ent.TaskHistory) string {
	switch entry.Action {
	case "created":
		return "bg-primary"
	case "updated":
		return "bg-info"
	case "moved":
		return "bg-warning"
	case "completed":
		return "bg-success"
	case "deleted":
		return "bg-error"
	case "tagged":
		return "bg-secondary"
	default:
		return "bg-base-300"
	}
}

templ getStatusBadge(action string, details string) {
	if action == "moved" || action == "completed" {
		// Extract column from details if available
		if details != "" {
			switch {
			case containsString(details, "In Progress") || containsString(details, "in_progress"):
				<span class="badge badge-warning badge-xs">In Progress</span>
			case containsString(details, "Review") || containsString(details, "review"):
				<span class="badge badge-secondary badge-xs">Review</span>
			case containsString(details, "Done") || containsString(details, "done"):
				<span class="badge badge-success badge-xs">Done</span>
			case containsString(details, "Backlog") || containsString(details, "backlog"):
				<span class="badge badge-neutral badge-xs">Backlog</span>
			}
		}
	} else if action == "tagged" {
		// Show the tag if we can extract it
		if details != "" {
			<span class="badge badge-warning badge-xs">{ details }</span>
		}
	}
}

func containsString(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > len(substr) && (s[:len(substr)] == substr || s[len(s)-len(substr):] == substr || findSubstring(s, substr)))
}

func findSubstring(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
